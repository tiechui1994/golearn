## 静态库和动态库

[cgo使用注意](https://www.bandari.net/blog/24)

CGO 在使用 C/C++ 资源的时候一般有三种形式: 直接使用源码; 链接静态库; 链接动态库.

直接使用源码就是在 `import "C"` 之前的注释部分包含C代码, 或者在当前包中包含 C/C++ 源文件.

链接静态库和链接动态库方式比较类似, 都是通过在 `LDFLAGS` 选项指定要链接的库方式链接.


### 使用 C 静态库

如果 CGO 中引入的 C/C++ 资源有代码而且代码规模比较小, 直接使用源码是最理想的方式, 但是很多时候
并没有源代码, 或者从 C/C++ 源代码开始构建的过程异常复杂, 这种时候使用 C 静态库是一个不错的选择.

静态库因为是静态链接, 最终的目标程序并不会产生额外的运行时依赖, 也不会出现动态库特有的跨运行时资源
管理的错误. 不过静态库在链接阶段会有一定要求: 静态库一般包含了全部的代码, 里面会有大量的符号, 如果
不同静态库之间出现了符号冲突则会导致链接的失败.

```cgo
// math.h
#ifdef  _ADD_H
#define _ADD_H
int add(int,int);
#endif

// math.c
#include "add.h"
int add(int a, int b) {
    return a+b;
}
```

因为 CGO 使用的是 GCC 命令来编译和链接C和Go桥接的代码. 因此静态库也必须是GCC兼容的格式.

生成 libmath.a 静态库:

```
gcc -c -o math.o math.c
ar rcs libmath.a math.o
```

由于有 math 库的全部代码, 所以可以使用 `go generate` 工具来生成静态库, 或者是通过 `Makefile`
来构建静态库. 因此发布 CGO 源码包, 并不需要提前构建 C 静态库.


为了支持 `go get` 命令直接下载并安装, C 语言的 `#include` 语法可以将 `math` 库的源文件链接到
当前的包.

创建 `z_link_math.c` 文件如下:

```
#include "./math.c"
```

然后在执行 `go get` 或 `go build` 之类的命令时, CGO 就是自动构建 `math` 库对应的代码. 这种技
术是在不改变静态库源代码组织结构的前提下, 将静态库转化为源代码方式引用.  这种 CGO 包是最完美的.

---

如果使用的是第三方的静态库, 需要先下载安装静态库到合适的位置. 然后在 `#cgo` 指令中通过 `CFLAGS`
和 `LDFLAGS` 来指定头文件和库的位置. 


### 使用 C 动态库
