## set 的实现

涉及的1个参数:

```
set-max-intset-entries 512
```

## intset 

intset 是由整数组成的集合. 实际上, intset是一个由整数组成的有序集合, 从而便于二分查找, 用于快速判断一个元素是否在这个
集合当中. 

在内存分配上, intset 和 ziplist 是类似的, 是连续的一整块内存空间, 而且对于大整数和小整数(按绝对值)采用了不同的编码, 
尽量对内存的使用进行了优化.

定义:

```cgo
typedef intset struct {
    uint32_t encoding;
    uint32_t length;
    int8_t   contents[];
} intset;
```

- encoding 数据编码, 表示intset采用几个字节存储. 三种可能: 2(int16), 4(int32), 8(int64)

- length 表示 intset 当中元素的数量个数.

- contents 柔性数组, 存储 intset 的数据元素. 这个数组的总长度等于 encoding*length


intset 的查找是而一个二分查找.


## set 的底层结构的变化

set 底层的数据结构是 intset 和 dict.

使用 intset 需要满足的条件:

- 所有的元素都是整数

- 整数的范围 -2^64 ~ 2^64-1

- 添加都set的元素数量不能超过 `set-max-intset-entries`

当添加元素不满足上述的条件时, set 的底层数据结构将转换为 dict.

dict 的 key 就是添加的元素, value 是 NULL


## set 的交,并,差集

- 交集

1) 检查各个集合, 对于不存在的集合当中空集合处理. 一旦出现空集, 最终的结果就是空

2) 对各个集合个数按照从小到大的顺序进行排序. 

3) 对排序后第一个集合进行遍历, 对于它的每一个元素, 依次在后面的所有集合中进行查找. 只有在所有集合都能找到时,才加入到结果
集当中.

> 注: 第3步在集合中进行查找, 对于 intset 和 dict 的时间复杂度分别是 O(lgn) 和 O(1). 由于小集合才使用 intset, 因此
粗略认为 intset 查询时间复杂度也是常数. 交集时间复杂度: O(N*M), N是最小的集合, M是交集的个数

- 差集

第一种算法:

对第一个集合进行遍历, 对于它的每一个元素, 依次查找后面的所有的集合, 只有当所有集合都找不到的元素, 才加入到最后的结果集合
中.

时间复杂度 O(N*M), 其中, N 是第一个集合的元素个数, M是集合数目

第二种算法:

1) 将第一个集合的元素加入到一个中间集合中.

2) 遍历后面所有的所有集合(需要按照集合元素数量递减排序), 对于碰到的每一个元素, 从中间集合当中删掉.

3) 最后的中间集合就构成了差集.

时间复杂度是 O(N), 其中 N 是所有集合元素的总个数.

计算差集时, 会先计算预测的时间复杂度, 然后按照时间复杂度低的进行计算.

