## 内存对齐

为什么需要内存对齐?

- 平台(移植性)原因: 不是所有的硬件平台都能够访问任意地址上的任意数据. 例如: 特定的硬件平台只允许在特定地址获取特定类型的
数据, 否则会导致异常状况.

- 性能原因: 若访问未对齐的内存, 将会导致CPU进行两次内存访问, 并且要花费额外的时钟周期来处理对齐及运算. 而本身就对齐的内
存仅需要一次访问就可以完成读取动作.


默认系数:

在不同的平台上的编译器有自己默认的"对齐系数", 可以通过预编指令 `#pragmapack(n)` 进行变更. n 就是代指"对齐系数". 一般
来讲, 常用的平台对齐系数是: 32位是4, 64位是8.

在 Go 当中, 可以使用函数 `unsafe.Alignof()` 来返回相应类型的对齐系数.


结构体内存对其的规则:

1. 结构体的成员变量, 第一个成员变量的偏移量是0. 往后的每个**成员变量的对齐值**必须为 **编译器默认长度** 或 **当前成员
变量类型的长度(`unsafe.Sizeof()`)**, 取 **最小值作为当前类型的对齐值**. **其偏移量必须为当前成员变量的对齐值的整数倍.**

2. 结构体本身, 对齐值必须为 **编译器默认的对齐长度** 或 **结构体所有的成员变量类型中的最大长度**, 取 **最大数的最小整
数倍** 作为对齐值.

3. 结合上述两点, 可得知: 若 **编译器默认对齐长度** 超过结构体内成员变量类型的最大长度时, 默认对齐长度是没有任何意义的.

换个说法:

- 对于具体类型来说, 对齐值=min(默认编译器对齐值, 类型大小的Sizeof长度). 也就是在默认设置的对齐值和类型的内存占用大小
之间. 取最好值为该类型的对齐值.

- struct 在每个字段都内存对齐之后, 其本身也要进行对齐, 对齐值=max(编译器默认对齐值, 字段最大类型长度). struct 的所
有字段中, 最大的那个类型长度以及编译器默认对齐值之间, 取对小的那个.

> 核心: 先进行成员对齐(根据1确定当前成员的偏移量), 然后进行整体对齐(根据2确定结构体的对齐值或者长度)

案例分析:

```
type Part struct {
    a bool
    b int32
    c int8
    d int64
    e byte
}
```

| 成员变量 | 类型 | 偏移量 | 自身占用 |
| --- | --- | --- | --- |
| a | bool | 0 | 1 |
| 字节对齐 | 无 |  |  |
| b | int32 | 4 | 4 |
| c | int8 | 8 | 1 |
| 字节对齐 | 无 |  |  |
| d | int64 | 16 | 8 |
| e | byte | 24 | 1 |
| 字节对齐 | 无 |  |  |


成员对齐:

- 第一个成员 a
    - 类型是 bool, 对齐值为 1 字节, 初始地址, 偏移量为 0 (占用1个字节, 后面的偏移量从1开始)

- 第二个成员 b
    - 类型是 int32, 对齐值为 4 字节, 偏移量为4 (根据规则1,偏移量必须是4的倍数) (占用4个字节, 后面的偏移量从8开始)

- 第三个成员 c
    - 类型是 int8, 对齐值是 1 字节, 偏移量为 8 (根据规则1,偏移量必须是1的倍数) (占用了1个字节, 后面偏移量从9开始)

- 第四个成员 d
    - 类型是 int64, 对齐值是 8 字节, 偏移量为 16 (根据规则1, 偏移量必须是8的倍数) (占用了8字节, 后面偏移量从24开始)

- 第五个成员 e
    - 类型是 byte, 对齐值是 1 字节, 偏移量是 24 (根据规则1, 偏移量必须是1的倍数) (占用1个字节, 后面偏移量从25开始)

    
整体对齐:

- 在每个成员变量对齐后, 根据规则2, 整个结构体本身也是要进行字节对, 对齐值是 8, 偏移量必须是8的倍数, 因此确定偏移量为32. 
对结构体对齐.

> - 结构体的偏移量从0开始计算, 每个成员的偏移量 + 当前成员的对齐值 = 下一个成员的偏移量. 
> - 当前成员的偏移量 == N * 当前成员的对齐值. 其中 N 取最小的整数. 使用此种方式计算当前成员的偏移量.
> - 结构体的大小 == N * max(结构体成员的对齐值). 其中 N 取最下的整数. 使用此种方式来计算结构体的大小.

结果:

Part内存布局为: `axxx|bbbb|cxxx|dddd|dddd|exxx|xxxx`. 其中 `x` 表示内存空洞.

