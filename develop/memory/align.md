## 内存对齐

为什么需要内存对齐?

- 平台(移植性)原因: 不是所有的硬件平台都能够访问任意地址上的任意数据. 例如: 特定的硬件平台只允许在特定地址获取特定类型的
数据, 否则会导致异常状况.

- 性能原因: 若访问未对齐的内存, 将会导致CPU进行两次内存访问, 并且要花费额外的时钟周期来处理对齐及运算. 而本身就对齐的内
存仅需要一次访问就可以完成读取动作.


默认系数:

在不同的平台上的编译器有自己默认的"对齐系数", 可以通过预编指令 `#pragmapack(n)` 进行变更. n 就是代指"对齐系数". 一般
来讲, 常用的平台对齐系数是: 32位是4, 64位是8.

在 Go 当中, 可以使用函数 `unsafe.Alignof()` 来返回相应类型的对齐系数.


结构体内存对其的规则:

1. 结构体的成员变量, 第一个成员变量的偏移量是0. 往后的每个成员变量的对齐值必须为**编译器默认长度(`#pragmapack(n)`)**
或 **当前成员变量类型的长度(`unsafe.Sizeof()`)**, 取**最小值作为当前类型的对齐值**. 其偏移量必须为对齐值的整数倍.

2. 结构体本身, 对齐值为**编译器默认的对齐长度(`#pragmapack(n)`)** 或 **结构体所有的成员变量类型中的最大长度**, 取
**最大数的最小整倍数** 作为对齐值.

3. 结合上述两点, 可得知若 **编译器默认对齐长度(`#pragmapack(n)`)`** 超过结构体内成员变量类型的最大长度时, 默认对齐
长度是没有任何意义的.

