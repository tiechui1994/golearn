## 函数调用

### 进程在内存中的布局

严格意义上是进程在虚拟地址空间的布局.

操作系统把磁盘上可执行文件加载到内存运行之前, 需要做很多工作, 其中很重要的一件事就是**把可执行文件中的代码, 数据存放到内存
中合适的位置, 并分配和初始化程序运行过程中必须的堆栈**, 所有准备工作完成之后操作系统才会调度程序起来运行.

![image](/images/develop_runtime_pmem.png)

进程在内存中布局主要分为4个区域: 代码区, 数据区, heap和stack.

- 代码区, 包括被CPU执行的机器代码(指令)和只读数据比如字符串常亮, 程序一旦加载完成代码区大小就不会再变化了. "代码"就是编
译器编译成机器代码的结果.

- 数据区, 包括程序的全局变量和静态变量(C语言有静态变量, Go没有), 与代码区一样, 程序加载完毕后数据区的大小也不会发生变化.

- heap, 程序运行时动态分配的内存位于 heap 中, 这部分内存由内存分配器负责管理. **该区域的大小会随着程序的运行而变化**.
当我们向 heap 请求分配内存但分配器发现 heap 当中内存不足时, 它会向操作系统内核申请向高地址方向扩展堆的大小, 而当我们释
放内存把它归还给堆时, 如果内存分配器发现剩余空闲内存太多, 则又会向操作系统请求向低地址方向收缩堆的大小.

### 函数调用栈

函数调用栈简称栈, 在程序运行过程中, 不管是函数执行还是函数调用, 栈都非常关键, 它的主要作用:

- 保存函数的局部变量;

- 向被调用函数传递参数;

- 返回函数的返回值;

- 保存函数的返回地址. **返回地址是指从被调用函数返回后调用者应该继续执行的指令地址**

每个函数在执行过程中都需要使用一块栈内存用来保存上述这些值, 称这块栈内存为函数的栈帧(stack frame). 当发生函数调用时, 
因为调用者还没有执行完成, 其栈内存中保存的数据还有用, 所以被调用函数不能覆盖调用者的栈帧, 只能把 `被调用函数` 的栈帧 
"push" 到栈上, 等 `被调用函数` 执行完成后再将其栈帧从栈上 "pop" 出去. 这样, 栈大小随着函数调用层级的增加而生长, 随函
数的返回而缩小. 

AMD64 CPU 提供了2个与栈相关的寄存器:

- **rbp寄存器, 一般用来指向函数栈帧的开始位置(高地址)**

- **rsp寄存器, 始终指向函数调用栈栈顶(低地址)**


函数调用栈以及rsp/rbp与栈之间的关系:

函数调用链: `A()->B()->C()`, 并且正在执行函数 `C()`.

![image](/images/develop_runtime_abcstack.png)

说明:

1. 调用函数时, 参数和返回值都是存放在调用者的栈帧之中, 而不是被调用函数之中;

2. 当前正在执行C函数, 且函数调用链为 `A()->B()->C()`, 以栈帧为单位的话, C函数的栈帧目前位于栈顶;

3. CPU 硬件寄存器 rsp 指向整个栈的栈顶, 当然它也指向C函数的栈帧的栈顶, 而 rbp 寄存器指向C函数栈帧的起始位置;

4. 有些编译器比如 gcc 会把参数和返回值放在 "寄存器" 中而不是栈中, go 语言中函数的参数和返回值都是放在栈上的;

> - gcc 参数寄存器: DI, SI, DX, R10, R8 R9, R12
> - gcc 返回值寄存器: AX, DX
>
> 系统调用当中, 使用 AX 存储系统调用号.

随着程序的运行, 如果 C, B 两个函数都执行完成并返回到A函数继续执行, 则栈的状态如下:

![image](/images/develop_runtime_astack.png)

由于 C, B 两个函数都已经执行完成并返回到 A 函数之中, 所以 C, B 两个函数的栈帧就已经被 POP 出栈了, 也就是说它们所消耗
的栈内存被自动回收了. 因为现在正在执行的 A 函数, 所以寄存器 rsp, rbp 指向的是 A 函数的栈中相应位置.


### 函数调用相关的汇编指令

- call/ret 

```
call 目标地址
ret
```

**call, 执行函数调用. 当 CPU 执行 call 指令时, 首先会把 rip 寄存器的值入栈, 然后设置 rip 为调用函数地址, 由于 rip 寄存器的值决定了下一条CPU需要执行指令的位置, 所以当 CPU 执行完成当前 call 指令后就会跳转到目标地址.**

**ret, 用于从被调用函数返回到调用函数, 它的实现原理是把 call 指令入栈的 "返回地址" 弹出给 rip 寄存器**

> 注: 在执行 ret 指令之前, 需要确保 rbp 寄存器的值已经恢复到 "被调用函数栈帧的起始位置", rsp 寄存器的值是 "被调用函数的
栈帧的结束位置(也就是调用函数的开始位置)". (leave指令就可以该功能)


- push/pop

```
push 源操作数
pop 目标操作数
```

用于函数调用栈的 "入栈" 和 "出栈" 指令, **这两个指令会自动修改 rsp 寄存器.**

push 入栈时, rsp 寄存器的值先减去 8 把栈位置留出来, 然后把操作数复制到 rsp 所指定位置. push 指令相当于:

```
sub $8, %rsp
mov 源操作数, 0(%rsp)
```

pop 出栈时, 先把 rsp 寄存器所指位置的数据复制到目的操作数中, 然后 rsp 寄存器的值加 8. pop 指令相当于:

```
mov 0(%rsp), 目标操作数
add $8, %rsp
```

- leave

leave 指令没有操作数, 它一般放在函数的尾部 ret 指令之前, 用于调整 rsp 和 rbp, 这条指令相当于:

```
mov %rbp, %rsp
pop %rbp
```

### 函数调用过程

问题:

- CPU 是如何从 "调用函数" 跳转到 "被调用函数" 的?

- 参数是如何从 "调用函数" 传递给 "被调用函数" 的?

- 函数局部变量所占内存是怎样在栈上分配的?

- 返回值是如果从 "被调用函数" 返回给 "调用函数" 的?

- 函数执行完成之后又需要做哪些清理工作?


相对于 go, C 语言更接近硬件, 编译后的汇编代码也更加简单直观, 更容易掌握函数调用的基本原理.

#### C 语言函数调用过程:

```cgo
#include <stdio.h>

int sum(int a, int b)
{
    int s = a + b;

    return s;
}

int main(int argc, char *argv[])
{
    int n = sum(1, 2);

    printf("n: %d\n", n);

    return 0;
}
```

用 gcc 编译(`gcc -g -o call call.c`)这个程序得到可执行程序 call, 然后 gdb 调试. 在 gdb 中通过 `disass main`
反汇编 main 函数找到 main 的第一条指针所在的地址 `0x000000000040113c`, 然后使用 `b *0x000000000040113c` 在该
地址打一个断点并运行程序:

```
(gdb) disass main
Dump of assembler code for function main:
  0x0000000000400540 <+0>: push  %rbp
  0x0000000000400541 <+1>: mov   %rsp,%rbp
  0x0000000000400544 <+4>: sub   $0x20,%rsp
  0x0000000000400548 <+8>: mov   %edi,-0x14(%rbp)
  0x000000000040054b <+11>:mov   %rsi,-0x20(%rbp)
  0x000000000040054f <+15>:mov   $0x2,%esi
  0x0000000000400554 <+20>:mov   $0x1,%edi
  0x0000000000400559 <+25>:callq 0x400526 <sum>
  0x000000000040055e <+30>:mov   %eax,-0x4(%rbp)
  0x0000000000400561 <+33>:mov   -0x4(%rbp),%eax
  0x0000000000400564 <+36>:mov   %eax,%esi
  0x0000000000400566 <+38>:mov   $0x400604,%edi
  0x000000000040056b <+43>:mov   $0x0,%eax
  0x0000000000400570 <+48>:callq 0x400400 <printf@plt>
  0x0000000000400575 <+53>:mov   $0x0,%eax
  0x000000000040057a <+58>:leaveq
  0x000000000040057b <+59>:retq  
End of assembler dump.
(gdb) b *0x0000000000400540
Breakpoint 1 at 0x400540
(gdb) r
Starting program: /home/bobo/study/c/call
Breakpoint 1, 0x0000000000400540 in main ()
```

注: 反汇编结果中的最左边的 `=>` 符号, 它表示这条指令是CPU将要执行的下一条指令, 也就是rip寄存器当前的值, 当前的状态是前
一条指令已经执行完毕, 这一条指令还为开始执行. 使用 `info registers rbp rsp rip` 查看当前的 rbp, rsp 和 rip三个寄存器的值:

```
(gdb) info registers rbp rsp rip
rbp   0x4005800x400580 <__libc_csu_init>
rsp   0x7fffffffe5180x7fffffffe518
rip   0x4005400x400540 <main>
```

根据这些寄存器的值, 当前时刻调用栈, rbp, rsp 和 rip 的关系如下:

![image](/images/develop_runtime_cfun1.png)

> rbp, rsp 和 rip 寄存器存储的都是地址, 因此这个几个寄存器都相当于一个指针. 上图当中, rip指向的是main函数第一条指令,
> rsp指向当前函数调用的栈栈顶, **rbp寄存器并未指向我们关注的栈和指令, 因此未画出它的具体指向, 只是显示了它的值.**

现在开始执行第1条指令:

```
0x0000000000400540 <+0>: push %rbp  # 保存调用者的 rbp 值
```

这条指令把调用者栈基地址 rbp 临时保存在main函数的栈帧里, 因为 main 函数需要使用rbp来存放自己的栈基地址. 调用者在调用
main 函数之前也把它的栈基地址保存在了rbp里, 因此main函数需要把rbp寄存器里的值先保存起来, 等main函数执行完成之后返回时
在将rbp恢复原样. 如果不恢复原样, mai n函数返回后调用者使用rbp寄存器时就会又问题.

**在这条指令之前, 代码还在调用者的栈帧, 执行完这条指令之后, 开始使用main函数的栈帧**. 目前mian函数的栈帧里只保存了调用
者的rbp这一个值. 在继续执行下一条指令之前, 栈和寄存器的状态如下: (标红的指令表示已经完成执行的指令.)

![image](/images/develop_runtime_cfun2.png)

> push 指令会修改 rsp 值. rip 值的修改是 CPU 自动完成的, CPU知道它要执行的每一条指令的长度有几个字节, 因此可
以自动计算出下一条指令的位置 (rip = rip + 指令长度). 

接着执行第2条指令:

```cgo
0x0000000000400541 <+1>: mov %rsp,%rbp  # 调整 rbp 寄存器,使其指向 main 函数栈帧起始位置
```

这条指令把 rsp 值拷贝给 rbp (指向main函数栈帧的起始位置), 这条指令执行完成之后, rsp 和 rbp 寄存器具有相同的
值, 它们都指向了函数战阵的起始位置.

![image](/images/develop_runtime_cfun3.png) 

接着执行第3条指令:

```cgo
0x0000000000400544 <+4>: sub $0x20, %rsp  # 调整 rsp 值, 为局部和临时变量分配栈空间
```

这条指令把 rsp 寄存器的值减去 0x20, 使其指向栈空间中一个更低的位置. 这一步看似是修改了 rsp 寄存器的值, 实质上是给 main 
函数的局部变量和临时变量预留了 32 字节空间. 为何是预留而不是分配? **因为栈的分配是操作系统自动完成的, 程序启动时操作系统
就会给我们分配一大块内存用作函数调用栈, 程序到底使用了多少栈内存由 rsp 栈顶寄存器来确定**.

该条指令执行完成之后, rsp所指位置和rbp所指位置的这一段区域的栈内存构成了main函数的完整的栈帧. 大小是40字节(8字节保存调
用者的rbp, 32字节保存main函数局部和临时变量).

![image](/images/develop_runtime_cfun4.png)


接着执行第4条指令:

```
0x0000000000400548 <+8> : mov %edi,-0x14(%rbp) # 保存main函数的第1个参数
0x000000000040054b <+11>: mov %rsi,-0x20(%rbp) # 保存main函数的第2个参数
0x000000000040054f <+15>: mov $0x2,%esi        # sum 函数的第2个参数放入esi寄存器
0x0000000000400554 <+20>: mov $0x1,%edi        # sum 函数的第1个参数放入edi寄存器
```

前2条指令负责把main函数的2个参数保存到栈帧里面. 这里面使用的是 rbp 加偏移量的方式来访问栈内存. 这里之所以要保存 main
函数的两个参数, 是因为调用者在调用 main 函数时使用了 edi 和 rsi 两个寄存器来给 main 函数分别传递 argc, argv 这两个
参数, 而 main 当中又需要这两个寄存器给 sum 传递参数, 因此为了不覆盖 argc 和 argv, 所以这里需要先把两个参数保存到栈中,
然后把传递给 sum 函数的两个参数放入到这两个寄存器当中. 


后2个指令负责为后续的 sum 函数调用准备参数. 传递的第1个参数放到了 edi 寄存器里, 第二个参数放到了 esi 寄存器里面. 
注: **在 gcc 当中, 函数调用时, 将第一个参数放入到 rdi, 第二个参数放入到 rsi, 第三个参数放入到 rdx, ... 这是一个约定**. 
在这里传递给 sum 的两个参数是使用 edi 和 esi, 而不是rdi和rsi, 原因在于 C 语言当中, int 是32位的, rdi, rsi都是64位的, edi
和esi可以分别当成rdi和rsi的一部分来使用.   

![image](/images/develop_runtime_cfun5.png)

接着执行第5条指令: (调用 sum 函数)

```
0x0000000000400559 <+25>: callq 0x400526 <sum>  # 调用 sum 函数
```

call 指令比较特殊, 刚开始执行它的时候, rip 执行的是 call 指令的下一条指令, 即 rip 值是 0x40055e 这个地址, 但在
call 指令执行过程中, call指令会把当前的 rip 的值(0x40055e) 入栈(会修改 rsp), 然后修改 rip 的值为 call 指令后面的操作数(这里是
0x400526, 即sum函数第一条指令的地址), 这样CPU就会跳转到sum函数去执行.

call 指令执行完成后栈和寄存器的状态如下:

![image](/images/develop_runtime_cfun6.png)


main当中执行了调用 sum 函数的 call 指令之后, CPU现在跳转到 sum 函数开始执行,

```
(gdb) disass
Dump of assembler code for function sum:
0x0000000000400526 <+0>: push  %rbp             # 保存调用者 rbp 值(入栈)             
0x0000000000400527 <+1>: mov   %rsp,%rbp        # 修改当前 rbp 的值
0x000000000040052a <+4>: mov   %edi,-0x14(%rbp) # 把第1个参数放入临时变量
0x000000000040052d <+7>: mov   %esi,-0x18(%rbp) # 把第2个参数放入临时变量
0x0000000000400530 <+10>: mov  -0x14(%rbp),%edx # 将第1个临时变量放入到 edx 当中
0x0000000000400533 <+13>: mov  -0x18(%rbp),%eax # 将第2个临时变量放入到 eax 当中
0x0000000000400536 <+16>: add  %edx, %eax       # 进行加法计算, 结果保存在 eax 当中
0x0000000000400538 <+18>: mov  %eax,-0x4(%rbp)  # 将 eax 的值保存到临时变量中
0x000000000040053b <+21>: mov  -0x4(%rbp),%eax  # 将临时变量的值放入到 eax 寄存器当中
0x000000000040053e <+24>: pop  %rbp             # 恢复调用者 rbp 值(出栈)
0x000000000040053f <+25>: retq                  # 函数返回
```

sum 函数并未像 main 函数一样通过调整 rsp 寄存器的值来给 sum 函数预留用于局部变量和临时变量的栈空间, 那这是不是说明
sum 函数就没有使用栈来保存局部变量呢? 其实不是, 从后面的分析看到, sum 函数的局部变量 s 还是保存在栈上的. 没有预留为什
么可以使用呢, 原因在于栈上的内存不需要在应用层代码中分配, 操作系统已经给我们分配好了, 可以尽管使用. **main函数需要调整
rsp寄存器的值是因为它需要使用 call 指令来调用 sum 函数, 而 call 指令会自动把rsp的值减去 8 然后把函数的返回地址保存到
rsp所指定的栈内存位置(即, call指令会自动将当前的rip的地址入栈), 如果 main 函数不调整 rsp 的值, 则 call 指令保存函数
返回地址时会覆盖局部变量或临时变量的值; 而 sum 函数中没有任何指令会自动使用 rsp 寄存器来保存数据到栈上, 所以不需要调整
rsp寄存器.**

![image](/images/develop_runtime_cfun8.png)

继续执行 retq 指令, 该指令把 rsp 指向的栈单元当中的 0x40055e 弹出(rsp 值会增加) 给 rip, 如此, rip 的值就变成了 main 函数中调用 sum 
的 call 指令的下一条指令, 于是返回到 main 函数中继续执行. 

![image](/images/develop_runtime_cfun9.png)

继续执行 main 函数中的:

```
mov %eax,-0x4(%rbp)  # 把sum函数的返回值赋给变量 n
```

该指令是把 rax 寄存器当中的值(sum函数返回值), 放入到 rbp-4 所指的内存, 也就是变量 n 所在的位置. 此时状态为:

![image](/images/develop_runtime_cfun10.png)


后面几条指令:

```cgo
0x0000000000400561 <+33>: mov   -0x4(%rbp),%eax # 将变量 n 的值放入 eax
0x0000000000400564 <+36>: mov   %eax,%esi       # 函数 printf 的第2个参数 
0x0000000000400566 <+38>: mov   $0x400604, %edi # 函数 printf 的第1个参数 
0x000000000040056b <+43>: mov   $0x0,%eax       # 函数 printf 返回值
0x0000000000400570 <+48>: callq 0x400400 <printf@plt> # 函数调用
0x0000000000400575 <+53>: mov   $0x0,%eax             # printf 返回值
```

首先为 printf 函数准备参数, 然后调用 printf 函数. 此时状态如下:

![image](/images/develop_runtime_cfun11.png)


接下来执行指令:

```
0x000000000040057a <+58>: leaveq
```

之前汇编曾说过, leave 指令先把 rbp 寄存器的值复制给 rsp, 这样, rsp 就指向了 rbp 的栈单元, 然后使该内存单元当中的值
POP出给 rbp 寄存器, 这样 rbp 和 rsp 就恢复到刚进入 main 函数时的状态了.

![image](/images/develop_runtime_cfun12.png)

到此, main 函数就只剩下 retq 指令了, 该条指令前面 sum 已经分析过了, 这条指令指向完成之后就会返回到调用 main 函数的函
数中继续执行.

#### Go 语言函数调用过程:

```cgo
package main

func sum(a, b int) int {
    a2 := a * a
    b2 := b * b
    c := a2 + b2
    
    return c
}

func main() {
    sum(1, 2)
}
```

使用 `go build -gcflags '-N -l' -o main main.go` 编译代码, 其中 `-gcflags '-N -l'` 是关闭编译器优化. 

首先来看 main 函数的反汇编代码: 

```
(gdb) disass main.main
Dump of assembler code for function main.main:
   0x000000000045dd40 <+0>:     mov    %fs:0xfffffffffffffff8,%rcx
   0x000000000045dd49 <+9>:     cmp    0x10(%rcx),%rsp
   0x000000000045dd4d <+13>:    jbe    0x45dd80 <main.main+64>
   0x000000000045dd4f <+15>:    sub    $0x20,%rsp           # 分配栈空间
   0x000000000045dd53 <+19>:    mov    %rbp,0x18(%rsp)      # 保留调用者的 rbp 值
   0x000000000045dd58 <+24>:    lea    0x18(%rsp),%rbp      # 重新设置当前的 rbp 的值(指向main函数帧栈开始地址)
   0x000000000045dd5d <+29>:    movq   $0x1,(%rsp)          # sum函数第一个参数(1)入栈
   0x000000000045dd65 <+37>:    movq   $0x2,0x8(%rsp)       # sum函数第二个参数(2)入栈
   0x000000000045dd6e <+46>:    callq  0x45dce0 <main.sum>  # 调用sum函数
   0x000000000045dd73 <+51>:    mov    0x18(%rsp),%rbp      # 恢复调用者 rbp 值
   0x000000000045dd78 <+56>:    add    $0x20,%rsp           # 恢复 rsp
   0x000000000045dd7c <+60>:    retq                        # 返回到调用者
   0x000000000045dd7d <+61>:    nopl   (%rax)
   0x000000000045dd80 <+64>:    callq  0x458c20 <runtime.morestack_noctxt>
   0x000000000045dd85 <+69>:    jmp    0x45dd40 <main.main>
End of assembler dump.
```

main 函数的前面三条指令和最后三条指令是go编译器用于检查栈溢出的代码, 不需要关注. 其他的部分和C语言中函数差不多, 不过差
别在于 `go语言函数调用时参数放在了栈上`(第7和第8条指令), 第4条指令, 编译器为main函数预留了32个字节用于存放main的栈帧
基地址rbp, 调用sum函数两个参数, sum函数的返回值, 刚好32个字节.


sum 函数的反汇编代码:

```
(gdb) disass main.sum
Dump of assembler code for function main.sum:
   0x000000000045dce0 <+0>:     sub    $0x20,%rsp      # 分配栈空间
   0x000000000045dce4 <+4>:     mov    %rbp,0x18(%rsp) # 保留调用者的 rbp 值
   0x000000000045dce9 <+9>:     lea    0x18(%rsp),%rbp # 重新设置当前的 rbp 的值 (指向 sum 函数帧栈开始地址)
   0x000000000045dcee <+14>:    movq   $0x0,0x38(%rsp) # 返回值初始化
   0x000000000045dcf7 <+23>:    mov    0x28(%rsp),%rax # 读取第一个参数a
   0x000000000045dcfc <+28>:    mov    0x28(%rsp),%rcx # 读取第一个参数a
   0x000000000045dd01 <+33>:    imul   %rax,%rcx       # 计算 a*a, 结果保存在 rcx
   0x000000000045dd05 <+37>:    mov    %rcx,0x10(%rsp) # 将rcx保存到变量 a2 上
   0x000000000045dd0a <+42>:    mov    0x30(%rsp),%rax # 读取第二个参数b
   0x000000000045dd0f <+47>:    mov    0x30(%rsp),%rcx # 读取第二个参数b
   0x000000000045dd14 <+52>:    imul   %rax,%rcx       # 计算 b*b, 保存到 rcx
   0x000000000045dd18 <+56>:    mov    %rcx,0x8(%rsp)  # 将rcx保存到变量 b2 上
   0x000000000045dd1d <+61>:    mov    0x10(%rsp),%rax # 将a2加载到 rax 当中
   0x000000000045dd22 <+66>:    add    %rcx,%rax       # a2+b2结果保留到rax
   0x000000000045dd25 <+69>:    mov    %rax,(%rsp)     # 将结果保留到c当中
   0x000000000045dd29 <+73>:    mov    %rax,0x38(%rsp) # 将结果复制给返回值
   0x000000000045dd2e <+78>:    mov    0x18(%rsp),%rbp # 恢复调用者 rbp 值
   0x000000000045dd33 <+83>:    add    $0x20, %rsp     # 恢复 rsp 值
   0x000000000045dd37 <+87>:    retq                   # 返回函数
End of assembler dump.
```

从汇编代码可以看到, sum 函数通过 rsp 寄存器从 main 函数栈中获取参数, 返回值也通过 rsp 保存在了 main 函数的栈帧中.

下图是已经执行完成sum函数的 `0x000000000045dd29 <+73>: mov %rax,0x38(%rsp)` 这条指令但未开始执行下一条指令时栈
以及栈寄存器的关系. 

![image](/images/develop_runtime_goreturn.png) 

**函数调用汇编的套路:**

1. **分配栈空间(修改 rsp 的值)**
2. **保存调用者的 rbp 值**
3. **设置当前函数的 rbp 的值**
4. 参数拷贝, 计算, 返回值设置等等
5. **恢复调用者的 rbp 值**
6. **恢复 rsp 值**
7. **函数返回, 从栈中弹出返回地址(rip的值)**

#### 函数调用过程总结: 

1. **参数传递. gcc编译的C/C++代码一般通过寄存器传递参数, 在AMD64 Linux平台, gcc约定函数调用时前6个参数分别通过rdi,
rsi, rdx, r10, r8, r9传递; 而 go语言函数调用时参数是通过栈传递给被调用函数的, 最后一个参数先入栈, 第一个参数后入栈,
参数在调用者栈帧之中, 被调用函数通过 rsp加一定的偏移量来获取参数;**

2. **call指令负责把执行call指令时rip寄存器(函数返回地址)入栈**

3. **gcc通过rbp寄存器加偏移量方式访问局部和临时变量, 而go编译器则使用rsp寄存器加偏移量的方式来访问它们;**

4. **ret指令负责把call指令入栈的返回地址出栈给rip, 从而实现从被调用函数返回到调用函数继续执行;**

5. **gcc使用rax寄存器返回函数调用的返回值, 而go使用栈返回函数调用的返回值.**

> 在 go 当中, 函数调用时, 先进行函数返回值(从后往前)初始化入栈, 然后进行函数参数入栈(从后往前). 

