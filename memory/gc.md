## Go 垃圾收集器的原理

### 标记清除

标记清除(Mark-Sweep) 算法是最常见的垃圾收集算法. 标记清除搜集器是跟踪式垃圾收集器, 其执行过程可以分为标记 (Mark), 和
清除(Sweep) 两个阶段:

1. 标记阶段 -- 从根对象出发查找并并发标记所有存活的对象;

2. 清除阶段 -- 遍历队中的全部对象, 回收未被标记的垃圾对象并将回收的内存加入空闲链表.

如图所示, 内存空间中包含多个对象, 我们从根对象出发依次遍历对象的子对象并将从根节点可达的对象编辑成存活状态, 即 A, C 和
D 三个对象, 剩余的 B, E 和 F 三个对象因为从根节点不可达, 所以会被当做垃圾:

![image](/images/gc_mark_sweep_1.png)


标记阶段结束后会进入清除阶段, 在该阶段中收集器会依次遍历堆中的所有对象, 释放其中没有被标记的 B, E 和 F 三个对象并将新的
空间以链表的结构串联起来, 方便内存分配器的使用.

![image](/images/gc_mark_sweep_2.png)


上述介绍的是最传统的标记清除算法, 垃圾收集器从垃圾收集的根对象出发, 地柜遍历这些对象指向的子对象并将所有可达的对象标记成
存活; 标记阶段结束后, 垃圾收集器会依次遍历堆中的对象并清除其中的垃圾, 整个过程需要标记标记对象的存活状态, 用户程序在垃圾
收集的过程中不能指向, 我们需要更复杂的机制来解决STW的问题.

### 三色抽象

为了解决原始标记清除算法带来的长时间 STW, 多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以缩短 STW 的时间. 三色
标记算法将程序中的对象分为白色, 黑色和灰色三类:

- 白色对象 -- 潜在的垃圾, 其内存可能会被垃圾收集器回收;

- 黑色对象 -- 活跃的对象, 包含**不存在任何引用外部指针的对象** 以及 **从跟对象可达的对象**;

- 灰色对象 -- 活跃的对象, 因为存在指向白色对象的外部指针, 垃圾收集器会扫描这些对象的子对象;


在垃圾收集器开始工作时, 程序中不存在任何的黑色对象, 垃圾收集的根对象会被标记为灰色, 来讲收集器只会从灰色对象结婚中取出
对象开始扫描, 当灰色集合中不存在任何对象时, 标记阶段就会结束.

![image](/images/gc_color_1.jpeg)


三色标记垃圾收集器的工作原理很简单, 分为以下结构步骤:

1.从灰色对象的集合中选择一个灰色对象并将其标记成黑色;

2.将黑色对象指向的所有对象都标记成灰色, 保证该对象和被该对象引用的对象都不会被回收;

3.重复上述的两个步骤直到对象图中不存在灰色对象;


当三个标记清除的 `标记阶段` 结束后, 应用程序的堆值就不存在任何的灰色的对象, 只能看到黑色的存活对象和白色的垃圾对象, 垃圾
收集器可以回收这些白色的垃圾. 下面是使用三色标记垃圾回收器执行标记后的堆内存, 堆中只有对象 D 为待回收的垃圾.

![image](/images/gc_color_marked.png)


`因为用户程序可能在标记执行的过程中修改对象的指针, 所以三色标记清除算法本身是不可以并发或者增量执行的, 它仍然需要 STW`.
在如下的三色标记过程中, `用户程序建立了从 A 对象到 D 对象的引用`, 但是因为程序中已经不存在灰色对象了, 所以 D 对象会被
垃圾收集器错误的回收.

![image](/images/gc_color_marking_ptr.png)


本来不该被回收的对象却被回收了, 这在内存管理中是非常严重的错误. 我们将这种错误称为悬挂指针, 即指针没有指向特定类型的合法
对象, 影响了内存的安全性. **想要并发或者增量地标记对象还是想要屏障技术**.


### 屏障技术

内存屏障技术是一种屏障指令,它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束, 目前的多数的现代处理器都会乱序执行
以最大化性能, 但是该技术能够保证**代码对内存操作的顺序性,在内存屏障前执行的操作一定会优先于内存屏障后执行的操作**.

想要在并发或者增量的标记中保证正确性, 需要达成以下两种三色不变性中的任意一种:

- 强三色不变性 -- 黑色对象不会指向白色对象, 只会指向灰色对象或者黑色对象;

- 弱三色不变性 -- **黑色对象指向白色对象必须包含一条 `从灰色对象经由多个(可以是0)白色对象的可达路径`**

![image](/images/gc_color_const.jpeg)


上图分别展示了遵循强三色不变性和弱三色不变性的堆内存, 遵循上述的两个不变性中的任意一个, 我们都能包装垃圾收集算法的正确性,
而屏障技术就是并发或者增量标记中保证三色不变性的重要技术.

垃圾收集中的屏障技术更像一个钩子函数, 它是在用户程序读取对象, 创建新对象以及更新对象指针时执行的一段代码, 根据操作类型的
不同, 可以将它们分成读屏障(Reader barrier) 和写屏障(Write barrier) 两种. 因为读屏障需要在读操作中加入代码片段, 对
用户程序的性能影响很大, 所以编程语言往往都会采用写屏障保证三色不变性.

这里介绍的是 Go 语言中使用的两种写屏障技术, 分别是插入写屏障 和 删除写屏障.


#### 插入写屏障

通过如下所示的插入写屏障, 用户程序和垃圾收集器可以交替工作的情况下保证程序执行的正确性:

```
writePointer(slot, ptr):
    shade(ptr)
    *field = ptr
```

> 每当执行类似 `*slot=pte` 的表达式时, 会指向上述写屏障通过 `shade` 函数尝试改变指针的颜色. 如果 `ptr` 指针是白色
> 的, 那么该函数会将该对象设置为灰色, 其他情况则保持不变.

![image](/images/gc_barrier_insert.png)

假设应用程序中使用插入写屏障, 在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程:

1.垃圾收集器将根对象指向A对象标记为黑色并将A对象指向的对象B标记为灰色;

2.用户程序修改A对象的指针, 将原本指向 B 对象的指针指向 C 对象, 这时触发写屏障将 C 对象标记为灰色;

3.垃圾收集器依次遍历程序中其他的灰色对象, 将它们分别标记为黑色;

插入写屏障是一种相对保守的屏障技术, 它会将 **有存活可能的对象都标记成灰色** 以满足 **强三色不变性**. 在如上所示的垃圾
收集过程中, 实际上不在存活的 B 对象最后没有被回收; 而如果在第二步和第三步之间将指向 C 对象的指针改回指向 B, 垃圾收集器
仍然认为 C 对象是存活的, 这些被错误标记的垃圾只有在下一个阶段才会被回收.


插入写屏障虽然实现非常简单并且也能保证强三色不变性, 但是它也有明显的缺点. 因为栈上的对象在垃圾回收中也会被认为是根对象,
所以保证内存的安全, 插入写屏障必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描, 这两种方法各有缺点,
前者会大幅度增加写入指针的额外开销, 后者重新扫描栈对象时需要暂停程序, 垃圾收集算法的设计需要在两者之间做出权衡.


#### 删除写屏障

一旦删除写屏障开始工作, 它就会保证开启写屏障时堆上所有对象的可达, 所以也被称为快照垃圾收集(Snapshot GC)

该算法会使用如下所示的写屏障保证增量或者并发执行垃圾收集时程序的正确性:

```
writePointer(slot, ptr)
    shade(*slot)
    *slot = ptr
```

上述代码会在老对象的引用被删除时, 将白色的老对象涂为灰色, **这样删除写屏障就可以保证弱三色不变性**, 老对象引用的下游对象
一定可以被灰色对象所引用.

![image](/images/gc_barrier_delete.png)

假设在应用程序中使用删除写屏障, 在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程:

1.垃圾收集器将根对象指向 A 对象标记为黑色并将 A 对象指向的 B 对象标记为灰色;

2.**用户程序将 A 对象原本指向 B 的指针指向 C, 触发删除写屏障, 但是因为 B 对已经是灰色的, 所以不做改变**;

3.**用户将 B 对象原本指向 C 的指针删除, 触发删除写屏障, 白色的 C 对象被标记为灰色**;

4.垃圾收集器依次遍历程序中的其他灰色对象, 将它们分别标记为黑色;

上述过程中的第三步触发了删除写屏障的着色, 因为用户程序删除了 B 指向 C 对象的指针, 所以 C 和 D 两个对象会分别违法强三色
不变性和弱三色不变性:

- 强三色不变性 -- 黑色的 A 对象直接指向白色的 C 对象;

- 弱三色不变性 -- 垃圾收集器无法从某个灰色对象出发, 经过几个连续的白色对象访问白色的 C 和 D 两个对象;

删除写屏障通过对 C 对象着色, 保证 C 对象和下游的 D 对象能够在一次垃圾收集的循环中存活, 避免发生悬挂指针以避免用户程序的
正确性.


### 增量和并发

传统的垃圾收集算法会在垃圾收集的执行期间暂停应用程序, 一旦触发垃圾收集, 垃圾收集器就会抢占 CPU 的使用权占据大量的计算资
源以完成标记和清除工作, 然而很多追求实时的应用程序无法接受长时间的 STW.


为了减少应用程序暂停的最长时间和垃圾收集的总暂停的时间, 会使用以下的策略优化垃圾收集器:

- 增量垃圾收集 -- 增量地标记和清除垃圾, 降低应用程序暂停的最长时间;

- 并发垃圾收集 -- 利用多核的计算资源, 在用户程序执行时并发标记和清除垃圾;

因为增量和并发两种方式都可以与用户程序交替运行, 所以我们需要使用屏障技术保证垃圾收集的正确性; 与此同时, 应用程序也不能等
到内存溢出时触发垃圾收集, 因为当内存不足时, 应用程序已经无法分配内存, 这与直接暂停程序没有任何区别, 增量和并发的垃圾收集
需要提前触发并在内存不足前完成整个循环, 避免程序的长时间暂停.


#### 增量收集器

增量式的垃圾收集是**减少程序最长暂停时间的一种方案**. 它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片, 虽然从
垃圾收集开始到结束的时间更长了, 但是这也是减少应用程序暂停的最大时间:

![image](/images/gc_incr.png)

> 增量式的垃圾收集需要与三色标记法一起使用, 为了保证垃圾收集的正确性, 需要在垃圾收集开始前打开写屏障, 这样用户程序对内存
> 的修改都会先经过写屏障的处理, 保证堆内存中对象的关系的强三色不变性或者弱三色不变性. 
>
> 虽然增量式的垃圾收集能够减少最大的程序暂停时间, 但是增量式收集也会增加一次 GC 循环的总时间, 在垃圾收集期间, 因为写屏障
> 的影响用户程序也需要承担额外的计算开销, 所以增量式的垃圾收集也不是只有优点的.


#### 并发收集器


并发的垃圾收集不仅能够减少程序的最长暂停时间, 还能减少整个垃圾收集阶段的时间, 通过开启读写屏障, 利用多核优势和用户程序并
行指向, 并发垃圾收集器确实能够减少垃圾收集对应用程序的影响.

![image](/images/gc_concur.png)

虽然并发收集器能够与用户程序一起运行, 但是并不是所有阶段都可以与用户程序一起运行, 部分阶段还是需要暂停用户程序的, 不过与
传统的算法相比, 并发的垃圾收集可以将能够并发执行的工作量尽量并发执行; 当然, 因为读写屏障的引入, 并发的垃圾收集器也一定会
带来额外开销, 不仅会增加垃圾收集的总时间, 还会影响用户程序.

